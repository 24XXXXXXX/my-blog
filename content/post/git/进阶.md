---
title: "Git 进阶：暂存区与 git add"
description: "理解工作区/暂存区/版本库，以及 git add（含 -A/. /-u/-p）如何记录新增、修改和删除。"
keywords: "git,git add,暂存区,staging area,git restore,git rm"

date: 2025-12-19T11:10:12+08:00
lastmod: 2025-12-19T11:10:12+08:00

math: false
mermaid: false

categories:
  - Git
tags:
  - Git
  - 暂存区
  - git add
---
这篇是 Git「进阶」部分，重点讲清楚 **暂存区（staging area / index）** 和 `git add` 的工作机制。

你会搞懂：为什么删除文件也能被 `git add -A`“添加”、`git add .` 和 `git add -A` 的差异到底在哪里、以及误删文件如何恢复。
<!--more-->

# 1.Git 的三区：工作区 / 暂存区 / 版本库

- **工作区（Working Tree）**：你磁盘上的真实文件。
- **暂存区（Index / Staging Area）**：下一次提交的“清单/快照”。
- **版本库（Repository）**：已提交的历史记录（`HEAD` 指向当前提交）。

可以用 `git status` 观察三者的关系：

- **Changes not staged for commit**：工作区变了，但暂存区还没记录。
- **Changes to be committed**：暂存区已经记录，等你 `git commit`。

# 2.`git add` 的本质：把“变更”记录进暂存区

很多人会把 `git add` 理解成“把文件加进去”，但更准确的说法是：

`git add` = **把工作区相对版本库的变更，写入暂存区**。

所以它能处理三类变更：

- **新增**：开始跟踪新文件。
- **修改**：把这次修改的内容写入暂存区。
- **删除**：把“删除这个文件”这件事写入暂存区。

# 3.为什么被删除的文件也能被 `git add -A` 添加？

关键点：`git add -A` 添加的不是“被删除的文件内容”，而是 **“删除”这个变更**。

示例（文件已被 Git 跟踪）：

1. 你删除 `old_file.txt`（资源管理器删除也一样）。
2. 执行：

```bash
git status
```

你会看到类似：

- `deleted: old_file.txt` 出现在 **Changes not staged for commit**

3. 执行：

```bash
git add -A
```

4. 再次查看：

```bash
git status
```

这时 `deleted: old_file.txt` 会出现在 **Changes to be committed**。

这表示暂存区记录的是：下一次提交时，把这个文件从版本库中移除。

# 4.如果回收站也清空了，还能 add 吗？

能，完全一样。

**Git 和操作系统回收站是两套系统**：

- 你是否清空回收站，只会影响“工作区最终有没有这个文件”。
- Git 只关心：工作区相对于版本库是否“缺了一个曾经存在的文件”。

只要文件在工作区里消失了，而它曾经被 Git 跟踪过，那么：

- `git status` 会看到删除
- `git add` 会把删除记录进暂存区
- `git commit` 会把删除写入历史

# 5.`git add .` vs `git add -A`：区别到底是什么？

你问的推断非常接近正确，但要补一个关键细节：

**差异的核心是“作用范围”**，而不是“是否能记录删除”。

## 5.1 对比表

| 命令 | 作用范围 | 处理新增 | 处理修改 | 处理删除 | 备注 |
| --- | --- | --- | --- | --- | --- |
| `git add -A` / `--all` | 整个仓库 | ✅ | ✅ | ✅ | 最“全”的选择 |
| `git add .` | 当前目录及子目录 | ✅ | ✅ | ✅（仅当前目录范围内） | 在子目录执行时容易漏掉别处的删除 |
| `git add -u` / `--update` | 整个仓库 | ❌ | ✅ | ✅ | 只处理已跟踪文件（不包含新文件） |

## 5.2 为什么有人说 `git add .` “不包含删除”？

更准确说法是：

`git add .` **可能**不会把删除加进来，通常是因为你执行命令的位置在某个子目录，删除发生在别的目录。

所以这句话：

> “`git add .` 比 `git add -A` 少了删除”

不严格成立。

严格结论是：

- 在仓库根目录执行：`git add .` 通常也会记录删除（根目录范围覆盖全仓库）。
- 在子目录执行：`git add .` 只能覆盖子目录内的变更，可能漏掉仓库其它位置的删除。

## 5.3 `git add` 能把被删除的文件“加回来”吗？

不能。

`git add` 只是“记录变更”，不是“逆转变更”。

想把文件加回来，需要用恢复命令（见第 7 节）。

# 6.只提交部分改动：`git add -p`

当一个文件改动很多，但你只想提交其中一部分时：

```bash
git add -p
```

它会把改动按 chunk 分块展示，你可以选择：

- `y` 暂存本块
- `n` 跳过本块
- `s` 拆分更小块
- `e` 手动编辑要暂存的内容

这是控制提交粒度的核心技能。

# 7.误删文件如何恢复（分情况）

## 7.1 刚删，还没 add/commit

把工作区文件恢复回来：

```bash
git restore path/to/file
```

（旧版本 Git 可用：`git checkout -- path/to/file`）

## 7.2 已经 `git add` 把“删除”暂存了，但还没 commit

先把暂存区的删除撤销，再恢复工作区：

```bash
git restore --staged path/to/file
git restore path/to/file
```

## 7.3 删除已经提交了

从历史某个提交把文件“取回来”：

```bash
git log --oneline -- path/to/file
git restore --source <commit> path/to/file
```

# 8.推荐的提交前检查流程

```bash
git status
git diff
git diff --staged
```

确保你清楚：哪些改动在工作区、哪些在暂存区，再去提交。
